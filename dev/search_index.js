var documenterSearchIndex = {"docs":
[{"location":"kernal/#Kernal","page":"Kernal","title":"Kernal","text":"","category":"section"},{"location":"kernal/#WannierExcitonModel.AbstractKernalInterAction","page":"Kernal","title":"WannierExcitonModel.AbstractKernalInterAction","text":"AbstractKernalInterAction\n\nThis abstract type is used to calculate kernal term in excitonic BSE model. You can design a concrete type of AbstractKernalInterAction according to your own needs.\n\nFor YourKernal, it should have specific fields:\n\nnk::Int: the number of kpoints;\nkgrid::RedKgrid: the kgrid used to calculate excitonic BSE model;\nkgrid_Γ::RedKgrid: with the same size of kgrid but without shift;\nkgrid_addmap::Matrix{Int}: satisfy kgrid[i] + kgrid[j] = kgrid_Γ[kgrid_addmap[i, j]]\nkgrid_minusmap::Matrix{Int}: satisfy kgrid[i] - kgrid[j] = kgrid_Γ[kgrid_minusmap[i, j]]\n\nYourKernal should support these methods:\n\n(K::YourKernal)(::Val{:initialize})\n\nIt's used to calculate some interaction matrix at first, for example W(k′-k); it will be run when create a BSE model.\n\n(K::YourKernal)(q::ReducedCoordinates)\n\nIt's used to calculate interaction matrix related to q, for example V(q) or J(k+k′+q); it will be run when calculate BSE Hamiltonian.\n\n(K::YourKernal)(k′, k, ψ₁, ψ₂, ψ₃, ψ₄)\n\nIt's used to calculate kernal matrix elements K_vckvck,\n\nk′ and k: it's the index of kpoints in kgrid list;\nψ: is a numerical vector; from left to right, in sequence: ψ_c^k+q, ψ_v^k, ψ_v^k, ψ_c^k+q.\n\nnote: Note\nYou can change inputs, but use local operation carefully. Do not forget the minus of Kᵈ.\n\nFor the case only refer to q in a specified qgrid, i.e. isqgrid is true, this also means k+q is in the kgrid for any q needed. In this case, YourKernal needs to support two more methods:\n\n(K::YourKernal)(::Val{:initialize_qgrid})\n\nIt's is a supplement to (K::YourKernal)(::Val{:initialize}); only run after (K::YourKernal)(::Val{:initialize}) when create BSE model.\n\n(K::YourKernal)(kq_kindex::Vector{Int}, kΓq_kΓindex::Vector{Int}, q::ReducedCoordinates)\n\nWhen isqgrid is true, BSEqgrid will not use (K::Kernal)(q::ReducedCoordinates) except when q equal to [0, 0, 0], instead of using this function.\n\nkq_kindex::Vector{Int}: kgrid[i] + q = kgrid[kq_kindex[i]];\nkΓq_kΓindex::Vector{Int}: kgrid_Γ[i] + q = kgrid_Γ[kq_kindex[i]];\n\n\n\n\n\n","category":"type"},{"location":"kernal/#UJ-approximation","page":"Kernal","title":"UJ approximation","text":"","category":"section"},{"location":"kernal/#WannierExcitonModel.Kernal_UJ-Tuple{MonkhorstPack, Vararg{Any}}","page":"Kernal","title":"WannierExcitonModel.Kernal_UJ","text":"Kernal_UJ(kgrid::Union{MonkhorstPack, RedKgrid}, \n\tKᵈ_U::UwithLR{UT_d, CT_d}, Kᵈ_J¹::AbstractReciprocalHoppings, Kᵈ_J²::AbstractReciprocalHoppings,\n\tKˣ_U::UwithLR{UT_x, CT_x}, Kˣ_J¹::AbstractReciprocalHoppings, Kˣ_J²::AbstractReciprocalHoppings;\n\tupindex::Union{<:AbstractVector{<:Integer}, Nothing} = nothing,\n\tdnindex::Union{<:AbstractVector{<:Integer}, Nothing} = nothing\n) -> AbstractKernalInterAction\n\nCreat a object which can be provided to canstruct a BSE model.\n\nkgrid: should be the same as excitonic basis;\nK_U: direct Coulomb interaction with long-range correction between electronic wannier basis;\nK_J: exchange Coulomb interaction between electronic wannier basis;\nup(dn)_index: the wannier basis index when contains spin.\n\nKᵈ needs screened coulomb interaction between wannier basis, while Kˣ needs naked coulomb interaction. The long-range behavior of direct Coulomb interaction between wannier basis is proportional to \\frac{1}{r}, we can't dismiss it. Check UwithLR to see how to contain the long-range correction. See more details about J¹ and J² in Theory.\n\nFor spinless case, you shouldn't provide upindex and dnindex. But for spinful case, you must provide at least one between upindex and dnindex. For spinful case, note that the interaction should not contain spin(see more details in Theory.)\n\nKernal_UJ(kgrid::Union{MonkhorstPack, RedKgrid}, \n\tKᵈ_U::UwithLR, Kᵈ_J¹::Union{AbstractString, HR}, Kᵈ_J²::Union{AbstractString, HR},\n\tKˣ_U::UwithLR, Kˣ_J¹::Union{AbstractString, HR}, Kˣ_J²::Union{AbstractString, HR};\n\tupindex::Union{<:AbstractVector{<:Integer}, Nothing} = nothing,\n\tdnindex::Union{<:AbstractVector{<:Integer}, Nothing} = nothing\n) -> AbstractKernalInterAction\n\nThis is a shortcut.\n\nnote: Note\nFor spinful case, we require that the electronic wannier basis satisfy time-reversal symmetry, so that we can define which term is U and which term is J.\n\n\n\n\n\n","category":"method"},{"location":"kernal/#U-approximation","page":"Kernal","title":"U approximation","text":"","category":"section"},{"location":"kernal/#WannierExcitonModel.Kernal_U-Tuple{MonkhorstPack, Vararg{Any}}","page":"Kernal","title":"WannierExcitonModel.Kernal_U","text":"Kernal_U(kgrid::Union{MonkhorstPack, RedKgrid}, \n\tKᵈ_U::UwithLR, Kˣ_U::UwithLR;\n\tupindex::Union{<:AbstractVector{<:Integer}, Nothing} = nothing,\n\tdnindex::Union{<:AbstractVector{<:Integer}, Nothing} = nothing\n) -> AbstractKernalInterAction\n\nCreat a object which can be provided to canstruct a BSE model.\n\nkgrid: should be the same as excitonic basis;\nK_U: direct Coulomb interaction with long-range correction between electronic wannier basis;\nup(dn)_index: the wannier basis index when contains spin.\n\nIts usage is similar to Kernal_UJ.\n\nnote: Note\nFor spinful case, we require that the electronic wannier basis satisfy time-reversal symmetry, so that we can define which term is U.\n\n\n\n\n\n","category":"method"},{"location":"rh/#Reciprocal-Hopping","page":"Reciprocal Hopping","title":"Reciprocal Hopping","text":"","category":"section"},{"location":"rh/","page":"Reciprocal Hopping","title":"Reciprocal Hopping","text":"This part is used to process the hopping terms of a tight binding model.","category":"page"},{"location":"rh/#HR","page":"Reciprocal Hopping","title":"HR","text":"","category":"section"},{"location":"rh/#WannierExcitonModel.HR","page":"Reciprocal Hopping","title":"WannierExcitonModel.HR","text":"HR{T <: Number}\n\nThe data in wannier90_hr.dat. Fields:\n\norbindex::Vector{Int}: the index of orbtal, usually equal to 1:norb;\npath::Matrix{Int}: its dimension is N × 5, each row is [Rx, Ry, Rz, i, j];\nvalue::Vector{T}: its length is N.\n\n\n\n\n\n","category":"type"},{"location":"rh/#construct","page":"Reciprocal Hopping","title":"construct","text":"","category":"section"},{"location":"rh/#WannierExcitonModel.HR-Tuple{AbstractMatrix{<:Integer}, AbstractVector{<:Number}}","page":"Reciprocal Hopping","title":"WannierExcitonModel.HR","text":"HR(path::AbstractMatrix{<:Integer}, value::AbstractVector{T}; orbindex = sort(unique(path[:, 4:5])), μ::Real = 0, hrsort = 'N') -> HR{T}\n\nCreate a HR object from path and value. \n\npath is a N × 5 matrix;\nvalue is a vector of length N;\norbindex is the orbital index list, default is as follows;\nμ is the fermi energy shift, default is 0.\nhrsort is whether to sort the hr by path, default is 'N', can be 'Y' or 'N'.\n\n\n\n\n\n","category":"method"},{"location":"rh/#Hopping","page":"Reciprocal Hopping","title":"Hopping","text":"","category":"section"},{"location":"rh/#WannierExcitonModel.Hopping","page":"Reciprocal Hopping","title":"WannierExcitonModel.Hopping","text":"Hopping{T <: Number}\n\nA Hopping represents a hopping term in a tight-binding model, defined by an initial orbital index i in unitcell [0, 0, 0], a final orbital index j in unitcell R (in reduced coordinates), and a hopping value t of type T.\n\njulia> hop = Hopping([1, 2, 3, 4, 5], 0.5)\nt₄₅[[1, 2, 3]] = 0.5\n\njulia> hop = Hopping(4, 5, [1, 2, 3], 0.5)\nt₄₅[[1, 2, 3]] = 0.5\n\njulia> path(hop)\n3-element ReducedCoordinates{Int64} with indices SOneTo(3):\n 1\n 2\n 3\n\njulia> value(hop)\n0.5\n\njulia> k = ReducedCoordinates([0.1, 0.2, 0.3]);\n\njulia> hopphase(hop, k) == exp(1im * 2π * (k ⋅path(hop)))\ntrue\n\n\n\n\n\n","category":"type"},{"location":"rh/#AbstractReciprocalHoppings","page":"Reciprocal Hopping","title":"AbstractReciprocalHoppings","text":"","category":"section"},{"location":"rh/#WannierExcitonModel.AbstractReciprocalHoppings","page":"Reciprocal Hopping","title":"WannierExcitonModel.AbstractReciprocalHoppings","text":"AbstractReciprocalHoppings{T <: Number}\n\nReorganized the storage form of the hopping terms to facilitate calculation.\n\nBaseReciprocalHoppings{T} <: AbstractReciprocalHoppings{T}\n\nA concrete type of AbstractReciprocalHoppings. But don't use BaseReciprocalHoppings directly.\n\n\n\n\n\n","category":"type"},{"location":"rh/#ReciprocalHoppings","page":"Reciprocal Hopping","title":"ReciprocalHoppings","text":"","category":"section"},{"location":"rh/#WannierExcitonModel.ReciprocalHoppings","page":"Reciprocal Hopping","title":"WannierExcitonModel.ReciprocalHoppings","text":"ReciprocalHoppings{T, U <: BaseReciprocalHoppings{T}} <: AbstractReciprocalHoppings{T}\n\njulia> hr isa HR\ntrue\n\njulia> rh = ReciprocalHoppings(hr);\n\njulia> k isa ReducedCoordinates\ntrue\n\njulia> rh(k);\n\n\n\n\n\n","category":"type"},{"location":"rh/#HermitianReciprocalHoppings","page":"Reciprocal Hopping","title":"HermitianReciprocalHoppings","text":"","category":"section"},{"location":"rh/#WannierExcitonModel.HermitianReciprocalHoppings","page":"Reciprocal Hopping","title":"WannierExcitonModel.HermitianReciprocalHoppings","text":"HermitianReciprocalHoppings{T <: Number, U <: AbstractReciprocalHoppings{T}} <: AbstractReciprocalHoppings{T}\n\njulia> hr isa HR\ntrue\n\njulia> hrh = HermitianReciprocalHoppings(hr);\n\njulia> k isa ReducedCoordinates\ntrue\n\njulia> hrh(k) isa Hermitian\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"start/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"start/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"WannierExcitonModel.jl can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg mode and run:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"pkg> add WannierExcitonModel","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Or, equivalently, via Pkg.jl:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"julia> import Pkg; Pkg.add(\"WannierExcitonModel\")","category":"page"},{"location":"start/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"To start using the package,","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"julia> using WannierExcitonModel","category":"page"},{"location":"start/#Accessing-documentation-from-REPL","page":"Getting Started","title":"Accessing documentation from REPL","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"The documentation for all the methods in WannierExcitonModel provides is also accessible via REPL. You can use the standard Julia way of searching (by typing ? followed by the function name) to get the documentation on REPL.","category":"page"},{"location":"io/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"io/","page":"IO","title":"IO","text":"This package provides some methods to read common files by overloading Base.read and Base.write.","category":"page"},{"location":"io/#FileFormat","page":"IO","title":"FileFormat","text":"","category":"section"},{"location":"io/#WannierExcitonModel.FileFormat","page":"IO","title":"WannierExcitonModel.FileFormat","text":"abstract type FileFormat end\n\nThe file format we supposed is its subtype.\n\nread(path::AbstractString, ::Type{T}; kwargs...) where{T <: FileFormat}\nread(io::IO, ::Type{T}; kwargs...) where{T <: FileFormat}\n\nRead data from a file or an IO stream in the specified file format.\n\nwrite(path::AbstractString, data, ::Type{T}; mode = \"w\", comment = \"\", kwargs...) where {T <: FileFormat}\nwrite(io::IO, data, ::Type{T}; comment = \"\", kwargs...) where {T <: FileFormat}\n\nWrite data to a file or an IO stream in the specified file format.\n\nmode: the write mode used by Base.open\ncomment: it's the comment line in file, and mostly is the first line.\n\n\n\n\n\n","category":"type"},{"location":"io/#POSCAR","page":"IO","title":"POSCAR","text":"","category":"section"},{"location":"io/#WannierExcitonModel.POSCAR","page":"IO","title":"WannierExcitonModel.POSCAR","text":"POSCAR is the input file of vasp, contains the structure of unitcell.\n\nread(path/io, ::Type{POSCAR}; period = Bool[1, 1, 1]) -> Cell\n\nperiod: represents the periodicity in three directions, should be a vector with 3 elements, and each elements should be 1 or 0.\n\nwrite(path/io, cell::Cell, ::Type{POSCAR}; format = \"Cartesian\")\n\nformat: can be \"Cartesian\" or \"Direct\".\n\n\n\n\n\n","category":"type"},{"location":"io/#QEcell","page":"IO","title":"QEcell","text":"","category":"section"},{"location":"io/#WannierExcitonModel.QEcell","page":"IO","title":"WannierExcitonModel.QEcell","text":"The format of cell structure block in pw.in.\n\nwrite(path/io, cell::Cell, ::Type{QEcell})\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90_centres.dat","page":"IO","title":"wannier90_centres.dat","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_centres","page":"IO","title":"WannierExcitonModel.wannier90_centres","text":"wannier90_centres.dat\n\nread(path/io, ::Type{wannier90_centres}) -> ORBITAL\n\nwrite(path/io, orbital::ORBITAL, ::Type{wannier90_centres})\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90_hr.dat","page":"IO","title":"wannier90_hr.dat","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_hr","page":"IO","title":"WannierExcitonModel.wannier90_hr","text":"wannier90_hr.dat\n\nread(path/io, ::Type{wannier90_hr}; heps::Real = 0, readimag = 'Y', μ::Real = 0, hrsort = 'N') -> HR\n\nheps::Real = 0, can be set as a random positive real number, which is used to filter small values.\nreadimag = 'Y', can be set as 'N' or 'n', which decides whether to read imaginary part.\nμ::Real = 0, can be set as a random real number, which is the chemical potential.\nhrsort = 'N', can be set as 'Y' or 'y', which decides whether to sort the HR object according to the standard order.\n\nwrite(path/io, hr::HR, ::Type{wannier90_hr})\n\n\n\n\n\n","category":"type"},{"location":"io/#BAND.dat","page":"IO","title":"BAND.dat","text":"","category":"section"},{"location":"io/#WannierExcitonModel.BAND_dat","page":"IO","title":"WannierExcitonModel.BAND_dat","text":"Its format is the same as \"BAND.dat\" generated by vaspkit, contains band structure.\n\nread(path/io, ::Type{BAND_dat}; readkname='N', smoothband='N') -> (band, kline)\n\nband: is a matrix with size (nband, nk);\nkline is a instance of Kline.\nreadkname determines whether the file contain the block of Kline.\n\nwrite(path/io, band, ::Type{BAND_dat}; kline)\n\nband: can be Eigen, Vector{Eigen} or AbstractVecOrMat{<:Real};\nkline: a instance of Kline with a empty default.\n\nnote: Note\n(nband, nk) = size(band)\n\n\n\n\n\n","category":"type"},{"location":"io/#RESPACKU","page":"IO","title":"RESPACKU","text":"","category":"section"},{"location":"io/#WannierExcitonModel.RESPACKU","page":"IO","title":"WannierExcitonModel.RESPACKU","text":"The format of output file dir-intW/dat.Wmat of RESPACK, also dir-intW/dat.Vmat.\n\nread(path/io, ::Type{RESPACKU}; norb::Integer) -> HR\n\nnorb::Integer, the number of orbitals.\n\nCompared to RESPACKJ, this method will read all the data in the file including onsite term.\n\n\n\n\n\n","category":"type"},{"location":"io/#RESPACKJ","page":"IO","title":"RESPACKJ","text":"","category":"section"},{"location":"io/#WannierExcitonModel.RESPACKJ","page":"IO","title":"WannierExcitonModel.RESPACKJ","text":"The format of output file dir-intJ/dat.Jmat of RESPACK, also dir-intW/dat.Xmat.\n\nread(path::AbstractString/io::IO, ::Type{RESPACKJ}; norb::Integer) -> HR\n\nnorb::Integer, the number of orbitals.\n\nCompared to RESPACKU, this method will read all the data in the file except onsite term.\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90.amn","page":"IO","title":"wannier90.amn","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_amn","page":"IO","title":"WannierExcitonModel.wannier90_amn","text":"wannier90.amn\n\nwrite(path/io, A::AbstractArray{<:Number}, ::Type{wannier90_amn})\n\n(nband, nwannier, nk) = size(A)\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90.mmn","page":"IO","title":"wannier90.mmn","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_mmn","page":"IO","title":"WannierExcitonModel.wannier90_mmn","text":"wannier90.mmn\n\nwrite(path/io, M::AbstractArray{<:Number}, ::Type{wannier90_mmn}; nnkpts::AbstractMatrix{<:Integer})\n\nM is a 3D array, the first two dimensions are band indices, the third dimension is k-b pair index.\nnnkpts is a 5xN matrix, each column is (ik1, ib2, G1, G2, G3) for one k-b pair, it must be provided.\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90.eig","page":"IO","title":"wannier90.eig","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_eig","page":"IO","title":"WannierExcitonModel.wannier90_eig","text":"wannier90.eig\n\nwrite(path/io, band, ::Type{wannier90_eig}; bandindex::AbstractVector{<:Integer})\n\nband can be a Eigen, or a vector of Eigen or a VecorMat of real numbers.\nbandindex is the index of bands to be written, default is all bands.\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90.win","page":"IO","title":"wannier90.win","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_win","page":"IO","title":"WannierExcitonModel.wannier90_win","text":"wannier90.win\n\nwrite(io::IO, cell::Cell, ::Type{wannier90_win}; kwargs...)\n\nkwargs:\n\nnum_iter: ;\nnum_print_cycles: default is 20;\nsearch_shells: default is 100;\nshell_list: default is nothing;\ndis_num_iter: ;\ndis_conv_tol: default is 1e-12;\ndis_conv_window: default is 5;\nexclude_bands: default is nothing;\nnum_bands: ;\ndis_win_min: ;\ndis_win_max: ;\ndis_froz_min: ;\ndis_froz_max: ;\nnum_wann: ;\nuse_bloch_phases: default is false;\nspinors: default is false;\nguiding_centres: default is false;\nprojections: default is nothing;\nwannier_plot: default is false;\nwannier_plot_format: default is \"xcrysden\";\nwannier_plot_supercell: default is nothing;\nbands_plot: default is false;\nbands_num_points: default is 30;\nbands_plot_format: default is \"gnuplot xmgrace\";\nkpoint_path: default is nothing, its format is the same as input of Kline;\ngrid: Union{MonkhorstPack, RedKgrid}.\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90.chk","page":"IO","title":"wannier90.chk","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_chk","page":"IO","title":"WannierExcitonModel.wannier90_chk","text":"wannier90.chk\n\nread(path/io, ::Type{wannier90_chk}) -> Wannier90chk\n\n\n\n\n\n","category":"type"},{"location":"io/#wannier90_w.xsf","page":"IO","title":"wannier90_w.xsf","text":"","category":"section"},{"location":"io/#WannierExcitonModel.wannier90_xsf","page":"IO","title":"WannierExcitonModel.wannier90_xsf","text":"wannier90_w.xsf\n\nread(path/io, ::Type{wannier90_xsf}) -> Wannier90xsf\n\n\n\n\n\n","category":"type"},{"location":"coulomb/#Coulomb","page":"Coulomb","title":"Coulomb","text":"","category":"section"},{"location":"coulomb/","page":"Coulomb","title":"Coulomb","text":"We provide some types to calculate different coulomb potentials.","category":"page"},{"location":"coulomb/#Real-space","page":"Coulomb","title":"Real space","text":"","category":"section"},{"location":"coulomb/#WannierExcitonModel.RealInverseR","page":"Coulomb","title":"WannierExcitonModel.RealInverseR","text":"RealInverseR(; ϵ::Real = 1) -> RealInverseR\n\nCalculate Coulomb potential generated by a point charge in real space:\n\nV(r) = frace²4πϵ₀ϵ frac1r\n\nunit: r(Å), V(eV), ϵ(dimensionless).\n\nExample\n\njulia> V = RealInverseR(; ϵ = 1.5)\njulia> r = [1.0, 0.0, 0.0] # or r = 1.0\njulia> V(r)\n\nNote V(0) = 0 here.\n\n\n\n\n\n","category":"type"},{"location":"coulomb/#WannierExcitonModel.RealGauss","page":"Coulomb","title":"WannierExcitonModel.RealGauss","text":"RealGauss(; ϵ::Real = 1, α::Real = 1) -> RealGauss\n\nCalculate Coulomb potential generated by a charge of Gaussian distribution in real space:\n\nV(r) = frace²4πϵ₀ϵ fracerf(αr)r\n\nunit: r(Å), V(eV), α(1/Å), ϵ(dimensionless).\n\nExample\n\njulia> V = RealGauss(; ϵ = 1.5, α = 2)\njulia> r = [1.0, 0.0, 0.0] # or r = 1.0\njulia> V(r)\n\n\n\n\n\n","category":"type"},{"location":"coulomb/#Reciprocal-space","page":"Coulomb","title":"Reciprocal space","text":"","category":"section"},{"location":"coulomb/#WannierExcitonModel.ReciprocalInverseR","page":"Coulomb","title":"WannierExcitonModel.ReciprocalInverseR","text":"ReciprocalInverseR(; ϵ::Real = 1, Ω::Real = 1) -> ReciprocalInverseR\n\nCalculate Coulomb potential generated by a point charge in reciprocal space:\n\nV(k) = frace²Ωϵ₀ϵ frac1k²\n\nunit: k(1/Å), V(eV), Ω(Å³), ϵ(dimensionless).\n\nExample\n\njulia> V = ReciprocalInverseR(; ϵ = 1.5, Ω = 10.0)\njulia> k = [1.0, 0.0, 0.0] # or k = 1.0\njulia> V(k)\n\nWe provide a method to calculate the head value:\n\nV(head) = fracNΩ(2π)³ int_0^q_sz V(k) 4πk² dk  \nfrac4π3q_sz^3 = frac(2π)³NΩ\n\njulia> V(:head, N)\n\n\n\n\n\n","category":"type"},{"location":"coulomb/#WannierExcitonModel.ReciprocalGauss3D","page":"Coulomb","title":"WannierExcitonModel.ReciprocalGauss3D","text":"ReciprocalGauss3D(; ϵ::Real = 1, α::Real = 1, Ω::Real = 1) -> ReciprocalGauss3D\n\nUnder 3D cases, calculate Coulomb potential generated by a charge of Gaussian distribution in reciprocal space:\n\nV(k) = frace²Ωϵ₀ϵ frac1k² e^-frack²4α²\n\nunit: k(1/Å), V(eV), Ω(Å³), α(1/Å), ϵ(dimensionless).\n\nExample\n\njulia> V = ReciprocalGauss3D(; ϵ = 1.5, α = 1.0, Ω = 10.0)\njulia> k = [1.0, 0.0, 0.0] # or k = 1.0\njulia> V(k)\n\nWe provide a method to calculate the head value:\n\nV(head) = fracNΩ(2π)³ int_0^q_sz V(k) 4πk² dk  \nfrac4π3q_sz^3 = frac(2π)³NΩ\n\njulia> V(:head, N)\n\n\n\n\n\n","category":"type"},{"location":"coulomb/#WannierExcitonModel.ReciprocalGauss2D","page":"Coulomb","title":"WannierExcitonModel.ReciprocalGauss2D","text":"ReciprocalGauss2D(; ϵ::Real = 1, α::Real = 1, S::Real = 1) -> ReciprocalGauss2D\n\nUnder 2D cases, calculate Coulomb potential generated by a charge of Gaussian distribution in reciprocal space:\n\nV(k z) = frace²4Sϵ₀ϵ frac1k left e^kz erfc(frack2α + αz) + e^-kz erfc(frack2α - αz) right\n\nunit: k(1/Å), z(Å), V(eV), S(Å²), α(1/Å), ϵ(dimensionless).\n\nExample\n\njulia> V = ReciprocalGauss2D(; ϵ = 1.5, α = 1.0, S = 10.0)\njulia> k = [1.0, 0.0, 0.0] # or k = 1.0\njulia> z = 0.5\njulia> V(k, z)\n\nWe provide a method to calculate the head value:\n\nV(head z) = fracNS(2π)² int_0^q_sz V(k) 2πk dk  \nπq_sz^2 = frac(2π)²NS\n\njulia> V(:head, N, z)\n\n\n\n\n\n","category":"type"},{"location":"uwithlr/#UwithLR","page":"UwithLR","title":"UwithLR","text":"","category":"section"},{"location":"uwithlr/#WannierExcitonModel.AbstractLRCorrection","page":"UwithLR","title":"WannierExcitonModel.AbstractLRCorrection","text":"abstract type AbstractLRCorrection end\n\nLong-range correction for coulomb interaction, can give the potential matrix in reciprocal space. It supports \n\n(v::AbstractLRCorrection)(k::AbstractVector)\n(v::AbstractLRCorrection)(k::AbstractVector, nk::Integer)\n(v::AbstractLRCorrection)(A::AbstractMatrix, k::AbstractVector)\n(v::AbstractLRCorrection)(A::AbstractMatrix, k::AbstractVector, nk::Integer)\n(v::AbstractLRCorrection)(::Val{+}, A, k::AbstractVector)\n(v::AbstractLRCorrection)(::Val{+}, A, k::AbstractVector, nk::Integer)\n\nThe methods involving nk can give head term when k is zero in all periodic directions.\n\n\n\n\n\n","category":"type"},{"location":"uwithlr/#WannierExcitonModel.UwithLR","page":"UwithLR","title":"WannierExcitonModel.UwithLR","text":"UwithLR{<: AbstractReciprocalHoppings, <: AbstractLRCorrection} <: AbstractInterAction\n\nDirect coulomb term between wannier basis with long-range correction. Fields:\n\nnorb::Int: the number of orbitals;\nSR::AbstractReciprocalHoppings: short-range part of direct term;\nLR::AbstractLRCorrection: long-range part of direct term.\n\nWe have achieved long-range correction by using Gauss potential. If you want to use other potential, you can define a new subtype of AbstractLRCorrection.  Make sure your subtype has methods:\n\n(v::yoursubtype)(::Val{+}, A, k::AbstractVector)\n(v::yoursubtype)(::Val{+}, A, k::AbstractVector, nk::Integer)\n\nFor an instance u of UwithLR, you can run:\n\njulia> u(k)\njulia> u(k, nk)\n\nThese two methods will create a new matrix. And u(k, nk) will judge whether head term or normal value by k.\n\njulia> u(A, k)\njulia> u(A, k, nk)\n\nThese two methods will change A instead of creating a new matrix.\n\n\n\n\n\n","category":"type"},{"location":"uwithlr/#construct","page":"UwithLR","title":"construct","text":"","category":"section"},{"location":"uwithlr/#WannierExcitonModel.UwithLR-Tuple{AbstractReciprocalHoppings, TightBindModel, Real}","page":"UwithLR","title":"WannierExcitonModel.UwithLR","text":"UwithLR(U, TB::TightBindModel, rcut::Real; kwargs...) -> UwithLR\n\nA shortcut to create a UwithLR. This long-range correction is achieved by using Gauss potential.\n\nU: the direct Coulomb potential between the wannier bases within a limited distance, can be a path::String, hr::HR or rh::AbstractReciprocalHoppings.\n\nkwargs:\n\nϵ::Real: dielectric constant;\nαrcut::Real: α × rcut, default is 4.5;\nδ:Real: the cutoff value of reciprocal potential.\n\n\n\n\n\n","category":"method"},{"location":"mirror_correction/#Mirror-Correction","page":"Mirror Correction","title":"Mirror Correction","text":"","category":"section"},{"location":"mirror_correction/#WannierExcitonModel.MirrorCorrection-Tuple{HR, TightBindModel}","page":"Mirror Correction","title":"WannierExcitonModel.MirrorCorrection","text":"MirrorCorrection(U::HR, TB::TightBindModel, rcut::Real; kwargs...) -> HR\n\nTry to apply a mirror correction to U. This mirror correction is achieved by using Gauss potential.\n\nrcut::Real: should be less than a real radius value, out of which the U approximate to 1/r, default is judged by U and TB;\n\nkwargs:\n\nkgrid::MonkhorstPack: should be the kgrid used to calculate U, default is judged by U;\nϵ::Real: dielectric constant;\nαrcut::Real: α × rcut, default is 4.5;\nδ:Real: the cutoff value of reciprocal potential.\n\n\n\n\n\n","category":"method"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/#Model","page":"Public API","title":"Model","text":"","category":"section"},{"location":"api/#Tight-Binding-Model","page":"Public API","title":"Tight-Binding Model","text":"","category":"section"},{"location":"api/#BSE-Model","page":"Public API","title":"BSE Model","text":"","category":"section"},{"location":"api/#Interaction","page":"Public API","title":"Interaction","text":"","category":"section"},{"location":"api/#Coulomb-Potential","page":"Public API","title":"Coulomb Potential","text":"","category":"section"},{"location":"api/#Lattice-Direct-Interaction-with-Long-range-Correction","page":"Public API","title":"Lattice Direct Interaction with Long-range Correction","text":"","category":"section"},{"location":"api/#IO","page":"Public API","title":"IO","text":"","category":"section"},{"location":"bsemodel/#Excitonic-BSE-Model","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"The core of this package is to provide a general solution for establishing a excitonic Bethe-Salpeter model based on electronic Wannier functions, allowing users to customize the model while also implementing several typical scenarios (see more details in Theory).","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"For periodic cases:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"Fields information\nTB tight binding model\nscissor band gap correction\nkgrid list of kpoints k\nunitcell list of positive lattice vectors R\nvckmap see behind\nijRmap see behind\nbandk electronic band structure at each k, calculated when a BSE model is created\nbandkq electronic band structure at each k+q, calculated when calculated excitonic Hamiltonian\nKernal calculate K^d and K^x using electronic state which is without spin","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"For cluster cases:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"Fields information\nTB tight binding model\nscissor band gap correction\nvcmap see behind\nijmap see behind\nband electronic band structure at each k, calculated when a BSE model is created\nKernal calculate K^d and K^x using electronic state which is without spin","category":"page"},{"location":"bsemodel/#Construct","page":"Excitonic BSE Model","title":"Construct","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"We provide four BSE models at present, they can all be constructed by a general function BSE:","category":"page"},{"location":"bsemodel/#WannierExcitonModel.BSE","page":"Excitonic BSE Model","title":"WannierExcitonModel.BSE","text":"BSE(TB::AbstractTightBindModel, Kernal::AbstractKernalInterAction, sym::Symbol;\n\tkgrid::Union{MonkhorstPack, RedKgrid} = MonkhorstPack([1, 1, 1]), \n\tv::AbstractVector{<:Integer}, c::AbstractVector{<:Integer}, \n\tscissor::Real = 0, \n\tisqgrid::Bool = false) -> AbstractBSE\n\nCreate a BSE model, the type depends on sym.\n\nTB::AbstractTightBindModel: contains crystal structure and electronic band structure;\nKernal::AbstractKernalInterAction: describes how to calculate Kᵈ and Kˣ;\nsym::Symbol: can be set as :SU2, :general, :cluster_SU2, :cluster_general;\nkgrid::Union{MonkhorstPack, RedKgrid}: defines the electronic kgrid used to construct the basis of exciton;\nv::AbstractVector{<:Integer}: the valence band index used to construct the basis of exciton;\nc::AbstractVector{<:Integer}: the conduction band index used to construct the basis of exciton;\nscissor::Real: scissor operator used to provide electronic band gap correction;\nisqgrid::Bool: when all the excitonic momentum needed can be regarded as the momentum difference in the kgrid.\n\n\n\n\n\n","category":"function"},{"location":"bsemodel/#The-type-of-BSE-Model","page":"Excitonic BSE Model","title":"The type of BSE Model","text":"","category":"section"},{"location":"bsemodel/#:SU2","page":"Excitonic BSE Model","title":":SU2","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"When any electronic state is doubly degenerated due to spin, excitonic states can be classified into the spin-singlet states and the spin-triplet states. In this case, you need to provide","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":" \nsym :SU2\nTB only contains one spin part, i.e. without spin\nKernal calculates K^d and K^x using electronic states that are without spin\nv and c the index of bands that are without spin","category":"page"},{"location":"bsemodel/#:general","page":"Excitonic BSE Model","title":":general","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"If any of the electronic states do not satisfy the spin degeneracy, we have to calculate the excitonic spin-singlet state and spin-triplet state at the same time. In this case, you need to provide","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":" \nsym :general\nTB contains the whole electron structure, i.e. with spin\nKernal calculates K^d and K^x using electronic states that contain spin\nv and c the index of bands that contain spin","category":"page"},{"location":"bsemodel/#:cluster_SU2","page":"Excitonic BSE Model","title":":cluster_SU2","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"This type is used when you model is a cluster and also spin degenerated. In this case, you only need to know that setting kgrid is a invalid operation. Remember to set period of TB as [0, 0, 0].","category":"page"},{"location":"bsemodel/#:cluster_general","page":"Excitonic BSE Model","title":":cluster_general","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"This type is used when you model is a cluster and also not spin degenerated. In this case, you only need to know that setting kgrid is a invalid operation. Remember to set period of TB as [0, 0, 0].","category":"page"},{"location":"bsemodel/#Kernal","page":"Excitonic BSE Model","title":"Kernal","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"Kernal is the most complex part of our BSE model, it is also the computational bottleneck because each element of the BSE Hamiltonian corresponds to a multiple summation. We provide two Kernel implementations under UJ approximation and the U approximation respectively.","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"note: Note\nFor spinful cases, we require that the electronic wannier basis satisfy time-reversal symmetry, so that we can define which term is U and which is J.","category":"page"},{"location":"bsemodel/#Excitonic-basis","page":"Excitonic BSE Model","title":"Excitonic basis","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"In our package, every state is actually a numerical vector. If you need to calculate some properties of a excitonic state, you may need know the basis order. We provide two types of excitonic basis, left vck rightrangle(for excitonic bloch function) and left ijR rightrangle(for the periodic part of excitonic bloch function).","category":"page"},{"location":"bsemodel/#\\left-vck-\\right\\rangle","page":"Excitonic BSE Model","title":"left vck rightrangle","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"If you already have a instance bse of type AbstractBSE, then you can get a vckMap by:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.vckmap\nvckMap(v = [1, 2], c = [3, 4], nk = 9)\n\njulia> length(bse.vckmap) == 2 * 2 * 9\ntrue\n\njulia> size(bse.vckmap)\n(2, 2, 9)\n","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"An object of vckMap supports bracket-based access to the basis's index.","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.vckmap[1]\n(1, 3, 1)\n","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"This will give the (vindex, cindex, kindex).","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.vckmap[1, 3, 1]\n1","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"This is a reverse access compared to the previous one.","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"You may find you also need a actual kpoint, not only a kindex.  The list of kpoints is bse.kgrid, you can get a kpoint by:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.kgrid[kindex]","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"For cluster, replace vckmap with vcmap:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.vcmap\nvcMap(v = [1, 2], c = [3, 4])\n\njulia> length(bse.vcmap) == 2 * 2\ntrue\n\njulia> size(bse.vcmap)\n(2, 2)\n","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"Also you can:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.vcmap[1]\n(1, 3)\n\njulia> bse.vcmap[1, 3]\n1\n","category":"page"},{"location":"bsemodel/#\\left-ijR-\\right\\rangle","page":"Excitonic BSE Model","title":"left ijR rightrangle","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"If you already have a instance bse of type AbstractBSE, then you can get a ijRMap by:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.ijRmap\nijRMap(norb = 4, nR = 9)\n\njulia> length(bse.ijRmap) == 4^2 * 9\ntrue\n\njulia> size(bse.ijRmap)\n(4, 4, 9)\n","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"An object of ijRMap supports bracket-based access to the basis's index.","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.ijRmap[1]\n(1, 1, 1)\n","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"This will give the (i, j, Rindex).","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.ijRmap[1, 1, 1]\n1\n","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"This is a reverse access compared to the previous one.","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"Also, you need a actual positive lattice vector, not only a Rindex.  The list of positive lattice vectors is bse.unitcell, you can get a R by:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.unitcell[Rindex]","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"For cluster, replace ijRmap with ijmap:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.ijmap\nijMap(norb = 4)\n\njulia> length(bse.ijmap) == 4^2\ntrue\n\njulia> size(bse.ijmap)\n(4, 4)\n","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"Also you can:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse.ijmap[1]\n(1, 1)\njulia> bse.ijmap[1, 1]\n1","category":"page"},{"location":"bsemodel/#Hamiltonian","page":"Excitonic BSE Model","title":"Hamiltonian","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"If you already have a instance bse of type AbstractBSE, then you can run:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> q = ReducedCoordinates(1, 2, 3)\njulia> bse(q)","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"to get Hamiltonian of the BSE model.","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"For cluster, you can run:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> q = ReducedCoordinates(0, 0, 0)\njulia> bse(q)","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"If the type of BSE is :SU2, bse(q) will return two matrixes at the same time:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> (Htriplet, Hsinglet) = bse(q);","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"If the type of BSE is :general, bse(q) will return one matrix:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> H = bse(q);","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"It also support changing a given matrix directly:","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> bse(Htriplet, Hsinglet, q) # For :SU2\njulia> bse(H, q) # For :spinful","category":"page"},{"location":"bsemodel/#BAND","page":"Excitonic BSE Model","title":"BAND","text":"","category":"section"},{"location":"bsemodel/#WannierExcitonModel.BAND-Tuple{AbstractVector{<:ReducedCoordinates}, WannierExcitonModel.BSESU2}","page":"Excitonic BSE Model","title":"WannierExcitonModel.BAND","text":"BAND(qpoints, bse::AbstractBSE; vector::Bool = false, wfctype::Symbol = :Bloch, \n\tη::Real = 1 // 2, ηt::Real = η, ηs::Real = η)\n\nThis function can calculate the band structure of a BSE model.\n\nqpoints can be a AbstractBrillouinZone object, a vector of qpoints or a single qpoint, where qpoint should be a vector of 3 real numbers.\nvector can be set as true, which decides whether to output wavefunction.\nwfctype can be set as :Periodic, which decides the type of wavefunction.\nη is the parameter of excitonic periodic wavefunction, also determines the excitonic center position. For spinless BSE model, ηt and ηs can be set separately.\n\nWe provide two strategies to solve the BSE Hamiltonian eigenvalue problem: \n\nLinearAlgebra_BSEeigenStrategy <: BSEeigenStrategy\nKrylovKit_BSEeigenStrategy <: BSEeigenStrategy\n\nLinearAlgebra_BSEeigenStrategy: use LinearAlgebra to solve eigenvalue equation;\nKrylovKit_BSEeigenStrategy: use KrylovKit to solve eigenvalue equation.\n\nThe default strategy is LinearAlgebra_BSEeigenStrategy, which uses the built-in eigen function in Julia. When KrylovKit package is used, the default strategy is set as KrylovKit_BSEeigenStrategy automatically.\n\njulia> using KrylovKit; using ExcitonicWannierModel;\n\nYou can switch the strategy by calling set_BSE_eigen_strategy!(::Type{BSEeigenStrategy}) manually.\n\nWhen KrylovKit_BSEeigenStrategy is used, you can set parameters of KrylovKit.eigsolve by calling eigsolveconfigure!(; kwards...). For excitonic Hamiltonian here, the relevant kwargs are: howmany, which, verbosity, tol, krylovdim, maxiter, orth.\n\n\n\n\n\n","category":"method"},{"location":"bsemodel/#Expectation-of-operator","page":"Excitonic BSE Model","title":"Expectation of operator","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"You can also calculate the expectation value of an operator for each eigenstate, with the matrix representation of this operator. This is the same as tight-binding model","category":"page"},{"location":"bsemodel/#spin-operator","page":"Excitonic BSE Model","title":"spin operator","text":"","category":"section"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"For the spinful BSE models, we provide some methods to help you get the matrix representation of hatS_z and hatS^2.","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"julia> numorb(TB)\n6\njulia> TB(:spinmat, [1, 2, 3]) # equal to TB(:spinmat, [1, 2, 3], [4, 5, 6])","category":"page"},{"location":"bsemodel/","page":"Excitonic BSE Model","title":"Excitonic BSE Model","text":"Its unit is frachbar2.","category":"page"},{"location":"brillouin_zone/#Brillouin-Zone","page":"Brillouin Zone","title":"Brillouin Zone","text":"","category":"section"},{"location":"brillouin_zone/#MonkhorstPack","page":"Brillouin Zone","title":"MonkhorstPack","text":"","category":"section"},{"location":"brillouin_zone/#WannierExcitonModel.MonkhorstPack","page":"Brillouin Zone","title":"WannierExcitonModel.MonkhorstPack","text":"MonkhorstPack <: AbstractBrillouinZone\n\nPerform BZ sampling employing a Monkhorst-Pack grid.\n\njulia> kgrid = MonkhorstPack([5, 5, 1]; kshift = [1//2, 0, 0])\nMonkhorstPack([5, 5, 1], [0.5, 0.0, 0.0])\n\njulia> length(kgrid)\n25\n\n\n\n\n\n\n","category":"type"},{"location":"brillouin_zone/#RedKgrid","page":"Brillouin Zone","title":"RedKgrid","text":"","category":"section"},{"location":"brillouin_zone/#WannierExcitonModel.RedKgrid","page":"Brillouin Zone","title":"WannierExcitonModel.RedKgrid","text":"RedKgrid <: AbstractBrillouinZone\n\nActually it's a simple expansion of MonkhorstPack. It supports bracket-based access.\n\njulia> kgrid = MonkhorstPack([5, 5, 1]; kshift = [1//2, 0, 0])\nMonkhorstPack([5, 5, 1], [0.5, 0.0, 0.0])\n\njulia> kgrid = RedKgrid(kgrid)\nReducibal kgrids with 25 reducible k-points.\n\njulia> length(kgrid)\n25\n\njulia> kgrid[2]\n3-element ReducedCoordinates{Rational{Int64}} with indices SOneTo(3):\n -3//10\n -2//5\n   0\n\n\n\n\n\n\n","category":"type"},{"location":"brillouin_zone/#Kline","page":"Brillouin Zone","title":"Kline","text":"","category":"section"},{"location":"brillouin_zone/#WannierExcitonModel.Kline","page":"Brillouin Zone","title":"WannierExcitonModel.Kline","text":"Kline{L <: Real} <: AbstractBrillouinZone\n\nKline includes some useful fileds in order to calculate band structure.\n\nline::Vector{Float64}: used as the horizontal coordinate of the band structure;\nname::Vector{String}: the name of the high symmetry point;\nindex::Vector{Int}: the name of the high symmetry point.\n\nIt also supports bracket-based access.\n\njulia> kline[3]\n\n\n\n\n\n","category":"type"},{"location":"brillouin_zone/#WannierExcitonModel.Kline-Tuple{Integer, Cell}","page":"Brillouin Zone","title":"WannierExcitonModel.Kline","text":"Kline(nk::Integer, TB::AbstractTightBindModel/cell::Cell) -> Kline\nKline(hspoint::AbstractVector{<:Pair}, nk::Integer, lattice::Lattice/cell::Cell/TB::AbstractTightBindModel) -> Kline\n\nFor the first method, Kline will try to build a high symmetry path in FBZ.  But we have only implemented a few 2D scenarios at present, and we also support the automatic generation of Kline in 1D and 0D.\n\nFor other case, you need to provide high symmtry points by hspoint.  For example:\n\nhspoint = [\n\t\"L\" => [0.5, 0.5, 0.5],\n\t\"G\" => [0, 0, 0],\n\t\"X\" => [0.5, 0, 0.5],\n\t\"W\" => [0.5, 0.25, 0.75],\n\t\"L\" => [0.5, 0.5, 0.5],\n]\n\n\n\n\n\n","category":"method"},{"location":"brillouin_zone/#kgridmap","page":"Brillouin Zone","title":"kgridmap","text":"","category":"section"},{"location":"brillouin_zone/#WannierExcitonModel.kgridmap","page":"Brillouin Zone","title":"WannierExcitonModel.kgridmap","text":"kgridmap(aimkdirects, kdirects, mode = +) -> Matrix{Int}\n\nTry to get a map matrix between aimkdirects and kdirects.\n\njulia> M = kgridmap(aimkdirects, kdirects, +);\n\njulia> aimkdirects[M[i, j]] == mode(kdirects[i], kdirects[j])\ntrue\n\n\nWe also provide some shortcuts:\n\nkgridmap(kgrid::MonkhorstPack, mode = +)\nkgridmap(redkgrid::RedKgrid, mode = +)\n\n\n\n\n\n","category":"function"},{"location":"brillouin_zone/#fold2FBZ","page":"Brillouin Zone","title":"fold2FBZ","text":"","category":"section"},{"location":"brillouin_zone/#WannierExcitonModel.fold2FBZ","page":"Brillouin Zone","title":"WannierExcitonModel.fold2FBZ","text":"fold2FBZ(Rlattice::ReciprocalLattice, kpoints::AbstractVector{<:AbstractVector}) -> AbstractVector{<:AbstractVector}\nfold2FBZ(Rlattice::ReciprocalLattice, kpoint::AbstractVector{<:Real}) -> AbstractVector{<:Real}\n\nReturn the input's equivalent kpoints in FBZ.\n\n\n\n\n\n","category":"function"},{"location":"tbmodel/#Tight-Binding-Model","page":"Tight Binding Model","title":"Tight Binding Model","text":"","category":"section"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"This package provides a group of functions to process tight-binding model. The core object is TightBindModel, ","category":"page"},{"location":"tbmodel/#WannierExcitonModel.TightBindModel","page":"Tight Binding Model","title":"WannierExcitonModel.TightBindModel","text":"TightBindModel{T <: Number, U <: AbstractReciprocalHoppings{T}} <: AbstractTightBindModel\n\nA tight binding model object containing fields:\n\nlattice::Lattice{Float64}: Lattice of the system.\natom_name::Vector{String}: Names of atoms of the unit cell.\natom_location::Vector{ReducedCoordinates{Float64}}: Locations of atoms in reduced coordinates.\norb_name::Vector{String}: Names of orbitals of the unit cell.\norb_location::Vector{ReducedCoordinates{Float64}}: Locations of orbitals in reduced coordinates.\nH::HermitianReciprocalHoppings{T, U}: Hermitian Hamiltonian of the tight binding model.\nperiod::Vec3{Bool}: Periodicity of the system in each lattice basis direction.\n\nNote that the auxiliary basis of lattice in unperiodic directions should be vertical to the periodic directions.\n\nnumatom(TB::TightBindModel) -> Int\nnumorb(TB::TightBindModel) -> Int\n\nUsed to obtain the number of atoms or orbitals.\n\n\n\n\n\n","category":"type"},{"location":"tbmodel/#Construct","page":"Tight Binding Model","title":"Construct","text":"","category":"section"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"You can construct a TightBindModel by","category":"page"},{"location":"tbmodel/#WannierExcitonModel.TightBindModel-Tuple{}","page":"Tight Binding Model","title":"WannierExcitonModel.TightBindModel","text":"TightBindModel(;\n\thops::Union{AbstractString, HR, AbstractReciprocalHoppings},\n\tcell::Union{AbstractString, Cell},\n\torbital::Union{AbstractString, ORBITAL},\n\tperiod = Bool[1, 1, 1],\n)\n\nCreate an TightBindModel object. The AbstractString is the path to aim file, and check docstrings of HR, AbstractReciprocalHoppings, Cell and ORBITAL.\n\n\n\n\n\n","category":"method"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"We emphasize that there are three parts of TightBindModel are the important. They are:","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":" common file format\nlattice basis vector POSCAR.vasp\norbital center location wannier90_centres.xyz\nhopping terms wannier90_hr.dat","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"The simplest method to construct a TightBindModel is to run:","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"julia> TightBindModel(;\thops = \"wannier90_hr.dat\", cell = \"POSCAR.vasp\", orbital = \"wannier90_centres.xyz\", period)","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"Remember to set period.","category":"page"},{"location":"tbmodel/#Hamiltonian","page":"Tight Binding Model","title":"Hamiltonian","text":"","category":"section"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"If you already have a instance TB of type TightBindModel, then you can run:","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"julia> k = ReducedCoordinates(1, 2, 3)\njulia> TB(k)","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"to get Hamiltonian of the tight-binding model. Or you may want to store Hamiltonian matrix to a existing variable:","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"julia> k = ReducedCoordinates(1, 2, 3)\njulia> H = Matrix{Float64}(undef, numorb(TB), numorb(TB))\njulia> TB(H, k)","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"When you need the Hamiltonian under atom guage, whose eigen vectors represent left u_nmathbfk rightrangle(see more details in Theory), you can run:","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"julia> TB(k, TB.orb_location)\njulia> TB(H, k, TB.orb_location)","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"Under atom guage, you can also get the partial derivative of Hamiltonian from ","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"julia> TB(:partial, k)\njulia> TB(:partial, H, k)\njulia> size(H) == (numorb(TB), numorb(TB), 3)\ntrue","category":"page"},{"location":"tbmodel/#BAND","page":"Tight Binding Model","title":"BAND","text":"","category":"section"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"The function BAND is the core of this package.","category":"page"},{"location":"tbmodel/#WannierExcitonModel.BAND-Tuple{AbstractVector{<:ReducedCoordinates}, TightBindModel}","page":"Tight Binding Model","title":"WannierExcitonModel.BAND","text":"BAND(kpoints, TB::AbstractTightBindModel; vector::Bool = false, wfctype::Symbol = :Bloch)\n\nThis method can calculate the band structure of a tight-binding model.\n\nkpoints can be a AbstractBrillouinZone object, a vector of kpoints or a single kpoint, where kpoint should be a vector of 3 real numbers.\nvector can be set as true, which decides whether to output wavefunction.\nwfctype can be set as `:Periodic, which decides the type of wavefunction.\n\n\n\n\n\n","category":"method"},{"location":"tbmodel/#WannierExcitonModel.ExtractU-Tuple{Any, Any, TightBindModel}","page":"Tight Binding Model","title":"WannierExcitonModel.ExtractU","text":"ExtractU(kpoints, band, TB::AbstractTightBindModel) -> band_u\nExtractU(kpoints, band, orblocat::AbstractVector{<:ReducedCoordinates}) -> band_u\n\nThis function can extract the periodic part of the wavefunction from the bloch wavefunction.\n\nkpoints can be a AbstractBrillouinZone object, a vector of kpoints or a single kpoint, where kpoint should be a vector of 3 real numbers.\nband can be a vector of Eigen object or a single Eigen object.\nband_u is a vector of Eigen object or a single Eigen object depending on the input band.\n\n\n\n\n\n","category":"method"},{"location":"tbmodel/#Expectation-of-operator","page":"Tight Binding Model","title":"Expectation of operator","text":"","category":"section"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"You can calculate the expectation value of an operator for each eigenstate, with the matrix representation of this operator.","category":"page"},{"location":"tbmodel/#WannierExcitonModel.ExpectationValue-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:LinearAlgebra.Eigen}}","page":"Tight Binding Model","title":"WannierExcitonModel.ExpectationValue","text":"ExpectationValue(operator::AbstractMatrix{<:Number}, band::AbstractVector{<:Eigen}) -> Vector{Vector{Float64}}\nExpectationValue(operator::AbstractMatrix{<:Number}, band::Eigen) -> Vector{Float64}\n\nCalculate the expectation value of an operator for each eigenstate.\n\n\n\n\n\n","category":"method"},{"location":"tbmodel/#spin-operator","page":"Tight Binding Model","title":"spin operator","text":"","category":"section"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"For the simplest case where the tight-binding model contains spin, we can obtain the hatS_z matrix by:","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"julia> numorb(TB)\n6\njulia> TB(:spinmat, [1, 2, 3]) # equal to TB(:spinmat, [1, 2, 3], [4, 5, 6])","category":"page"},{"location":"tbmodel/","page":"Tight Binding Model","title":"Tight Binding Model","text":"The unit is frachbar2.","category":"page"},{"location":"structure/#Structure","page":"Structure","title":"Structure","text":"","category":"section"},{"location":"structure/","page":"Structure","title":"Structure","text":"We provide a group of types to help you build a crystalline structure. We draw inspiration from CrystallographyCore.jl to design some types. For most cases, these are only intermediate objects, and we use them to construct a Model type.","category":"page"},{"location":"structure/#Lattice","page":"Structure","title":"Lattice","text":"","category":"section"},{"location":"structure/","page":"Structure","title":"Structure","text":"It can be used just like a matrix.","category":"page"},{"location":"structure/#WannierExcitonModel.Lattice-Tuple{AbstractMatrix}","page":"Structure","title":"WannierExcitonModel.Lattice","text":"Lattice(data::AbstractMatrix) -> Lattice\n\nConstruct a Lattice from a matrix.\n\nnote: Note\nThe basis vectors of the matrix are stored as columns.\n\nExamples\n\njulia> Lattice([\n\t\t   1.2 4.5 7.8\n\t\t   2.3 5.6 8.9\n\t\t   3.4 6.7 9.1\n\t   ])\nLattice{Float64}\n 1.2  4.5  7.8\n 2.3  5.6  8.9\n 3.4  6.7  9.1\n\n\n\n\n\n","category":"method"},{"location":"structure/#WannierExcitonModel.Lattice-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"Structure","title":"WannierExcitonModel.Lattice","text":"Lattice(𝐚::AbstractVector, 𝐛::AbstractVector, 𝐜::AbstractVector) -> Lattice\n\nConstruct a Lattice from three basis vectors.\n\nExamples\n\njulia> 𝐚, 𝐛, 𝐜 = [1.2, 2.3, 3.4], [4.5, 5.6, 6.7], [7.8, 8.9, 9.10];\n\njulia> Lattice(𝐚, 𝐛, 𝐜)\nLattice{Float64}\n 1.2  4.5  7.8\n 2.3  5.6  8.9\n 3.4  6.7  9.1\n\n\n\n\n\n","category":"method"},{"location":"structure/#Coordinates","page":"Structure","title":"Coordinates","text":"","category":"section"},{"location":"structure/","page":"Structure","title":"Structure","text":"They can be created and used just like a vector.","category":"page"},{"location":"structure/#WannierExcitonModel.ReducedCoordinates","page":"Structure","title":"WannierExcitonModel.ReducedCoordinates","text":"Reduced Coordinates.\n\n\n\n\n\n","category":"type"},{"location":"structure/#WannierExcitonModel.CrystalCoordinates","page":"Structure","title":"WannierExcitonModel.CrystalCoordinates","text":"CrystalCoordinates = ReducedCoordinates\n\n\n\n\n\n","category":"type"},{"location":"structure/#WannierExcitonModel.CartesianCoordinates","page":"Structure","title":"WannierExcitonModel.CartesianCoordinates","text":"Cartesian Coordinates.\n\n\n\n\n\n","category":"type"},{"location":"structure/","page":"Structure","title":"Structure","text":"Example","category":"page"},{"location":"structure/","page":"Structure","title":"Structure","text":"using WannierExcitonModel\n\nlattice = Lattice([\n\t\t   1.2 4.5 7.8\n\t\t   2.3 5.6 8.9\n\t\t   3.4 6.7 9.1\n\t   ])\n\na = ReducedCoordinates(1, 2, 3)\nb = lattice * a\nlattice \\ b","category":"page"},{"location":"structure/#Cell","page":"Structure","title":"Cell","text":"","category":"section"},{"location":"structure/#WannierExcitonModel.Cell","page":"Structure","title":"WannierExcitonModel.Cell","text":"Cell{P <: Union{CartesianCoordinates{<:Real}, ReducedCoordinates{<:Real}}}\n\nContains all the information of a crystalline unitcell. Fields:\n\nlattice::Lattice{Float64}: lattice basis matrix;\nlocation::Vector{P}: all atoms' location;\nname::Vector{String}: all atoms' location;\nindex::Vector{Int}: all atoms' index;\nperiod::Vec3{Bool}: the periodicty of unitcell.\n\n\n\n\n\n","category":"type"},{"location":"structure/#construct","page":"Structure","title":"construct","text":"","category":"section"},{"location":"structure/#WannierExcitonModel.Cell-Tuple{Any, AbstractVector}","page":"Structure","title":"WannierExcitonModel.Cell","text":"Cell(lattice, location; location_type, name = String[], index = Int[], period = Bool[1, 1, 1])\n\nCreate a new cell.\n\nlattice: a Lattice type or a matrix, note the basis vectors of the matrix are stored as columns.\nlocation: a vector contains all atom's location, its length equal to N;\nlocation_type: \"Reduced\" or \"Cartesian\";\nname: a list of N values, where the same kind of name need to be a String.\nindex: a list of N values, where the same kind of index need to be a Integer.\nperiod: [1(0), 1(0), 1(0)].\n\nMake sure the basis at unperiodic direction is perpendicular to the other basis.\n\n\n\n\n\n","category":"method"},{"location":"structure/#ORBITAL","page":"Structure","title":"ORBITAL","text":"","category":"section"},{"location":"structure/#WannierExcitonModel.ORBITAL","page":"Structure","title":"WannierExcitonModel.ORBITAL","text":"ORBITAL{OT <: Real, AT <: Real}\n\nThe data in wannier90_centres.xyz. Fields:\n\nlocation::Vector{CartesianCoordinates{OT}}: location of orbital centres;\nname::Vector{String}: name of orbitals;\nindex::Vector{Int}: index of orbitals;\natom_location::Vector{CartesianCoordinates{AT}}: location of atoms;\natom_name::Vector{String}: name of atoms;\nbelonging::Vector{Int}: the index of atom that orbital belongs to.\n\n\n\n\n\n","category":"type"},{"location":"structure/#construct-2","page":"Structure","title":"construct","text":"","category":"section"},{"location":"structure/#WannierExcitonModel.ORBITAL-Tuple{AbstractVector}","page":"Structure","title":"WannierExcitonModel.ORBITAL","text":"ORBITAL(location::AbstractVector; name = String[], index = Int[], \n\tatom_location = CartesianCoordinates{Float64}[], atom_name = String[], belonging = Int[])\n\nCreate an ORBITAL object.\n\nlocation: a vector contains all the locations of orbitals, its length equals N;\nname and index: its element is the name or index of each orbital;\natom_location and atom_name: its element is the location or name of each orbital;\nbelonging: the i-th orbital belongs to the belonging[i]-th atom.\n\n\n\n\n\n","category":"method"},{"location":"#WannierExcitonModel.jl","page":"Home","title":"WannierExcitonModel.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package solving Excitonic Bethe-Salpeter equation(BSE) based on Electronic Wannier model.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a general solution for establishing a BSE model based on electronic Wannier functions, allowing users to customize the model while also implementing several typical scenarios.","category":"page"}]
}
