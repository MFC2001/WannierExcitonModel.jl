
export ReciprocalInverseR, ReciprocalGauss3D, ReciprocalGauss2D

(v::ReciprocalCoulomb)(sym::Symbol, nk::Integer) = v(Val(sym), nk)

struct ReciprocalInverseR <: ReciprocalCoulomb
	ϵ::Float64
	Ω::Float64
	CoulombScaleϵ::Float64
end
function (v::ReciprocalInverseR)(k::AbstractVector{<:Real})::Float64
	k² = k[1] * k[1] + k[2] * k[2] + k[3] * k[3]
	return k² == 0 ? 0.0 : v.CoulombScaleϵ / k²
end
function (v::ReciprocalInverseR)(k::Real)::Float64
	if k == 0
		return 0.0
	else
		return v.CoulombScaleϵ / (k * k)
	end
end
function (v::ReciprocalInverseR)(::Val{:head}, nk::Integer)::Float64
	NΩ = nk * v.Ω
	qsz = (6 * π^2 / NΩ)^(1 // 3)
	return v.CoulombScaleϵ * NΩ * qsz / (2 * π^2)
end
"""
	ReciprocalInverseR(; ϵ::Real = 1, Ω::Real = 1) -> ReciprocalInverseR

Calculate Coulomb potential generated by point charge in reciprocal space:

```math
V(k) = \\frac{e²}{Ωϵ₀ϵ} \\frac{1}{k²}
```

unit: k(1/Å), V(eV), Ω(Å³), ϵ(dimensionless).

# Example

```julia
julia> V = ReciprocalInverseR(; ϵ = 1.5, Ω = 10.0)
julia> k = [1.0, 0.0, 0.0] # or k = 1.0
julia> V(k)
```

We provide a method to calculate the head value:

```math
V(head) = \\frac{NΩ}{(2π)³} \\int_{0}^{q_{sz}} V(k) 4πk² dk , 
\\frac{4π}{3}q_{sz}^3 = \\frac{(2π)³}{NΩ}
```

```julia
julia> V(:head, N)
```
"""
function ReciprocalInverseR(; ϵ::Real = 1, Ω::Real = 1)
	CoulombScaleϵ = CoulombScale * 4π / (Ω * ϵ)
	return ReciprocalInverseR(ϵ, Ω, CoulombScaleϵ)
end

struct ReciprocalGauss3D <: ReciprocalCoulomb
	ϵ::Float64
	α::Float64
	Ω::Float64
	CoulombScaleϵ::Float64
	α²4::Float64
end
function (v::ReciprocalGauss3D)(k::AbstractVector{<:Real})::Float64
	k² = k[1] * k[1] + k[2] * k[2] + k[3] * k[3]
	return k² == 0 ? 0.0 : v.CoulombScaleϵ * exp(-k² / v.α²4) / k²
end
function (v::ReciprocalGauss3D)(k::Real)::Float64
	if k == 0
		return 0.0
	else
		k² = k * k
		return v.CoulombScaleϵ * exp(-k² / v.α²4) / k²
	end
end
function (v::ReciprocalGauss3D)(::Val{:head}, nk::Integer)::Float64
	NΩ = nk * v.Ω
	qsz = (6 * π^2 / NΩ)^(1 // 3)
	return v.CoulombScaleϵ * NΩ * v.α * erf(qsz / (2 * v.α)) / (2 * π^(3 // 2))
end
"""
	ReciprocalGauss3D(; ϵ::Real = 1, α::Real = 1, Ω::Real = 1) -> ReciprocalGauss3D

Under 3D case, calculate Coulomb potential generated by charge of Gaussian distribution in reciprocal space:

```math
V(k) = \\frac{e²}{Ωϵ₀ϵ} \\frac{1}{k²} e^{-\\frac{k²}{4α²}}
```

unit: k(1/Å), V(eV), Ω(Å³), α(1/Å), ϵ(dimensionless).

# Example

```julia
julia> V = ReciprocalGauss3D(; ϵ = 1.5, α = 1.0, Ω = 10.0)
julia> k = [1.0, 0.0, 0.0] # or k = 1.0
julia> V(k)
```

We provide a method to calculate the head value:

```math
V(head) = \\frac{NΩ}{(2π)³} \\int_{0}^{q_{sz}} V(k) 4πk² dk , 
\\frac{4π}{3}q_{sz}^3 = \\frac{(2π)³}{NΩ}
```

```julia
julia> V(:head, N)
```
"""
function ReciprocalGauss3D(; ϵ::Real = 1, α::Real = 1, Ω::Real = 1)
	CoulombScaleϵ = CoulombScale * 4π / (Ω * ϵ)
	α²4 = 4 * α^2
	return ReciprocalGauss3D(ϵ, α, Ω, CoulombScaleϵ, α²4)
end


struct ReciprocalGauss2D <: ReciprocalCoulomb
	ϵ::Float64
	α::Float64
	S::Float64
	CoulombScaleϵ::Float64
	α2::Float64
end
function (v::ReciprocalGauss2D)(k::AbstractVector{<:Real}, z::Real)::Float64
	k² = k[1] * k[1] + k[2] * k[2] + k[3] * k[3]

	if k² == 0
		return 0.0
	else
		k = √k²
		z = abs(z)

		αz = v.α * z
		ekz = exp(k * z)
		k2α = k / (v.α2)

		return v.CoulombScaleϵ * (erfc(k2α + αz) * ekz + erfc(k2α - αz) / ekz) / k
	end
end
function (v::ReciprocalGauss2D)(k::Real, z::Real)::Float64
	if k == 0
		return 0.0
	else
		z = abs(z)

		αz = v.α * z
		ekz = exp(k * z)
		k2α = k / (v.α2)

		return v.CoulombScaleϵ * (erfc(k2α + αz) * ekz + erfc(k2α - αz) / ekz) / k
	end
end
function (v::ReciprocalGauss2D)(::Val{:head}, nk::Integer, z::Real)::Float64
	NS = nk * v.S
	qsz = √(4 * π / NS)

	z = abs(z)

	qsz2α = qsz / (v.α2)
	if z == 0
		α2sπ = v.α2 / √π
		return v.CoulombScaleϵ * NS * (qsz * erfc(qsz2α) - α2sπ * exp(-qsz2α^2) + α2sπ) / π
	else
		eqz = exp(qsz * z)
		αz = v.α * z
		return v.CoulombScaleϵ * NS * (erfc(qsz2α + αz) * eqz - erfc(qsz2α - αz) / eqz + 2 * erf(αz)) / (2π * z)
	end
end
"""
	ReciprocalGauss2D(; ϵ::Real = 1, α::Real = 1, S::Real = 1) -> ReciprocalGauss2D

Under 2D case, calculate Coulomb potential generated by charge of Gaussian distribution in reciprocal space:

```math
V(k, z) = \\frac{e²}{4Sϵ₀ϵ} \\frac{1}{k} \\left[ e^{kz} erfc(\\frac{k}{2α} + αz) + e^{-kz} erfc(\\frac{k}{2α} - αz) \\right]
```

unit: k(1/Å), z(Å), V(eV), S(Å²), α(1/Å), ϵ(dimensionless).

# Example

```julia
julia> V = ReciprocalGauss2D(; ϵ = 1.5, α = 1.0, S = 10.0)
julia> k = [1.0, 0.0, 0.0] # or k = 1.0
julia> z = 0.5
julia> V(k, z)
```

We provide a method to calculate the head value:

```math
V(head, z) = \\frac{NS}{(2π)²} \\int_{0}^{q_{sz}} V(k) 2πk dk , 
πq_{sz}^2 = \\frac{(2π)²}{NS}
```

```julia
julia> V(:head, N, z)
```
"""
function ReciprocalGauss2D(; ϵ::Real = 1.0, α::Real = 1.0, S::Real = 1.0)
	CoulombScaleϵ = CoulombScale * π / (S * ϵ)
	α2 = 2 * α
	return ReciprocalGauss2D(ϵ, α, S, CoulombScaleϵ, α2)
end



# struct ReciprocalGaussAnisotropy3D <: ReciprocalCoulomb
# 	ϵ::Mat3{Float64}
# 	α::Float64
# 	Ω::Float64
# 	CoulombScale::Float64
# 	α²4::Float64
# end
# function (v::ReciprocalGaussAnisotropy3D)(k::AbstractVector{<:Real})::Float64
# 	k2 = k[1] * k[1] + k[2] * k[2] + k[3] * k[3]
# 	return k2 == 0 ? 0.0 : v.CoulombScale * exp(-k2 / v.α²4) / (transpose(k) * v.ϵ * k)
# end
# function ReciprocalGaussAnisotropy3D(; ϵ::AbstractMatrix{<:Real} = [1 0 0; 0 1 0; 0 0 1], α::Real = 1, Ω::Real = 1)
# 	CoulombScale = CoulombScale * 4π / Ω
# 	α²4 = 4 * α^2
# 	return ReciprocalGaussAnisotropy3D(ϵ, α, Ω, CoulombScale, α²4)
# end
