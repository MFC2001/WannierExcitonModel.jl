# A symmetry operation (SymOp) is a couple (W, w) of a matrix W and a translation w, in
# reduced coordinates, such that for each atom of type A at position a, W a + w is also an
# atom of type A.
# The matrix W is unitary in Cartesian coordinates, but not in reduced coordinates.
# This induces an operator in Reciprocal space
#   S = inv(W')

export SymOp, check_group, LattSymOp

struct ConjugateOperator end
Base.:(*)(::ConjugateOperator, c::Number) = conj(c)
Base.:(*)(c::Number, ::ConjugateOperator) = conj(c)
struct TimeReversalOperator end


struct SymOp
	W::Mat3{Int}
	w::Vec3{Float64}
	# in Reciprocal space
	S::Mat3{Int}
	# for time reversal, 1 represents no time-reversal and -1 represents time-reversal.
	t::Int
	#  旋量空间的转动矩阵
end
function SymOp(W::AbstractMatrix{<:Integer}, w::AbstractVector{<:Real}; t = 1)
	w = mod.(w, 1)
	# Accatually, it should be inv(W'), but in this programme we will apply it to the state, so we ommmit the inv.
	# After testing, W' and inv(W') both are ok.
	S = t * W'
	return SymOp(W, w, S, t)
end



# function Base.convert(::Type{SymOp}, S)
# 	return SymOp(S.W, S.w, S.S)
# end

Base.:(==)(op1::SymOp, op2::SymOp) = op1.W == op2.W && op1.w == op2.w
function Base.isapprox(op1::SymOp, op2::SymOp; symtol = 1e-5)
	return op1.W == op2.W && is_approx_integer(op1.w - op2.w; atol = symtol)
end

Base.one(::Type{SymOp}) = SymOp(Mat3{Int}(I), Vec3(zeros(Int, 3)))
Base.one(::SymOp) = one(SymOp)
Base.isone(op::SymOp) = isone(op.W) && iszero(op.w)


# group composition and inverse.
function Base.:(*)(op1::SymOp, op2::SymOp)
	W = op1.W * op2.W
	w = op1.W * op2.w + op1.w
	return SymOp(W, w)
end
function Base.:(*)(op::SymOp, vec::AbstractVector{<:Real})
	return op.W * vec + op.w
end
Base.inv(op::SymOp) = SymOp(inv(op.W), -op.W \ op.w)


function check_group(symops::AbstractVector{SymOp}; kwargs...)
	is_approx_in_symops(s1) = any(s -> isapprox(s, s1; kwargs...), symops)
	is_approx_in_symops(one(SymOp)) || error("check_group: no identity element")
	for s in symops
		if !is_approx_in_symops(inv(s))
			error("check_group: symop $s with inverse $(inv(s)) is not in the group")
		end
		for s′ in symops
			if !is_approx_in_symops(s * s′)
				error("check_group: product is not stable")
			end
		end
	end
	return symops
end



# symop.S*k = k′, H(k′) = U(k)H(k)U(k)', |nk′⟩ = U(k)|nk⟩
struct LattSymOp{UT <: Number}
	k::ReducedCoordinates{Rational{Int}}
	k′::ReducedCoordinates{Rational{Int}}
	symop::SymOp
	U::Matrix{UT}
end

"""
Only work for one case presently: 
All orbitals are the same, and only one orbital(or two orbitals with opposite spin) on every site. 
In this case, we can ignore the factor of phase generated by rotating.
"""
function symop2lattsymop(symop, orblocation, k, k′; symtol = 1e-5)
	norb = length(orblocation)
	U = zeros(ComplexF64, norb, norb)
	for i in 1:norb
		aim = findfirst(x -> _is_approx_integer(symop * orblocation[i] - x; atol = symtol), orblocation)
		if isnothing(aim)
			error("Can't identify operated orbital.")
		end
		T = round.(symop * orblocation[i] - orblocation[aim])
		U[i, aim] = cis(2π * k ⋅ T)
	end
	return LattSymOp(k, k′, symop, U)
end
